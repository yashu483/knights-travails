{"version":3,"file":"main.js","mappings":"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","sources":["webpack://knight-travails/./src/node.js","webpack://knight-travails/./src/knight-travails.js","webpack://knight-travails/./src/index.js"],"sourcesContent":["'use strict';\n\nclass Node {\n  constructor(vertex, creator = null) {\n    this.vertex = vertex;\n\n    // creator will be the neighbor node which created the current one.\n    this.creator = creator;\n    this.neighbors = this.findNeighbors(this.vertex);\n  }\n  findNeighbors(vertex) {\n    let neighbors = [];\n    const rowIndex = vertex[0];\n    const columnIndex = vertex[vertex.length - 1];\n    for (let i = 0; i < 8; i++) {\n      switch (i) {\n        case 0:\n          {\n            const traverseColumn = columnIndex - 1;\n            const traverseRow = rowIndex + 2;\n            if (traverseColumn < 0 || traverseRow > 7) break;\n            neighbors.push([traverseRow, traverseColumn]);\n          }\n          break;\n        case 1:\n          {\n            const traverseColumn = columnIndex - 2;\n            const traverseRow = rowIndex + 1;\n            if (traverseColumn < 0 || traverseRow > 7) break;\n            neighbors.push([traverseRow, traverseColumn]);\n          }\n          break;\n        case 2:\n          {\n            const traverseColumn = columnIndex - 2;\n            const traverseRow = rowIndex - 1;\n            if (traverseColumn < 0 || traverseRow < 0) break;\n            neighbors.push([traverseRow, traverseColumn]);\n          }\n          break;\n        case 3:\n          {\n            const traverseColumn = columnIndex - 1;\n            const traverseRow = rowIndex - 2;\n            if (traverseColumn < 0 || traverseRow < 0) break;\n            neighbors.push([traverseRow, traverseColumn]);\n          }\n          break;\n        case 4:\n          {\n            const traverseColumn = columnIndex + 1;\n            const traverseRow = rowIndex - 2;\n            if (traverseColumn > 7 || traverseRow < 0) break;\n            neighbors.push([traverseRow, traverseColumn]);\n          }\n          break;\n        case 5:\n          {\n            const traverseColumn = columnIndex + 2;\n            const traverseRow = rowIndex - 1;\n            if (traverseColumn > 7 || traverseRow < 0) break;\n            neighbors.push([traverseRow, traverseColumn]);\n          }\n          break;\n        case 6:\n          {\n            const traverseColumn = columnIndex + 2;\n            const traverseRow = rowIndex + 1;\n            if (traverseColumn > 7 || traverseRow > 7) break;\n            neighbors.push([traverseRow, traverseColumn]);\n          }\n          break;\n        case 7:\n          {\n            const traverseColumn = columnIndex + 1;\n            const traverseRow = rowIndex + 2;\n            if (traverseColumn > 7 || traverseRow > 7) break;\n            neighbors.push([traverseRow, traverseColumn]);\n          }\n          break;\n      }\n    }\n    return neighbors;\n  }\n}\n\nexport { Node };\n","'use strict';\n\nimport { Node } from './node';\n\n// given a node, finds path to the starting position using creator node chain.\n// creator node: every time a node will move to its neighbor so that neighbor node will be created, so who helps the creation of neighbor node is refer as creator\nconst path = function path(node, list = []) {\n  if (node.creator === null) {\n    list.unshift(node.vertex);\n    return list;\n  } else {\n    list.unshift(node.vertex);\n    return path(node.creator, list);\n  }\n};\n\n// helper function to check same arrays\nconst sameArrays = function sameArrays(arr1, arr2) {\n  if (arr1.length !== arr2.length) return false;\n\n  return arr1.every((item, index) => {\n    return item === arr2[index];\n  });\n};\n\n// given starting and ending position, returns the node for ending co-ordinates\nconst findEnd = function findEnd(vertex, desiredPosition) {\n  const node = new Node(vertex);\n  let currentRoot = node;\n  let que = [currentRoot];\n  const visitedNodes = [currentRoot.vertex];\n  let count = 0;\n  let pathFound = false;\n  let endPositionNode = null;\n  while (!pathFound) {\n    count += 1;\n    if (que[0] === null) {\n      que.shift();\n      currentRoot = que[0];\n      continue;\n    }\n    currentRoot.neighborNodes = [];\n    currentRoot.neighbors.forEach((item) => {\n      count += 1;\n      if (\n        !visitedNodes.some((element) => {\n          return sameArrays(element, item);\n        })\n      ) {\n        const newNode = new Node(item, currentRoot);\n        currentRoot.neighborNodes.push(newNode);\n        visitedNodes.push(newNode.vertex);\n        que.push(newNode);\n      }\n    });\n    pathFound = currentRoot.neighbors.some((item) => {\n      count += 1;\n      return sameArrays(item, desiredPosition);\n    });\n    if (pathFound) {\n      const desiredNode = currentRoot.neighborNodes.filter((item) => {\n        count += 1;\n        if (sameArrays(item.vertex, desiredPosition)) return true;\n        else {\n          return false;\n        }\n      });\n      endPositionNode = desiredNode[0];\n      return endPositionNode;\n    } else {\n      que.shift();\n      currentRoot = que[0];\n    }\n  }\n  console.log(`Total iteration: ${count}`);\n  return endPositionNode;\n};\nconst knightMoves = function knightMoves(start, end) {\n  if (\n    start[0] < 0 ||\n    start[0] > 7 ||\n    start[1] < 0 ||\n    start[1] > 7 ||\n    end[0] < 0 ||\n    end[0] > 7 ||\n    end[1] < 0 ||\n    end[1] > 7\n  ) {\n    alert(\n      `Invalid starting or ending co-ordinates. Please provide value between 0 to 7`,\n    );\n    return;\n  }\n  const getEndNode = findEnd(start, end);\n  return path(getEndNode);\n};\n\nexport { findEnd, path, sameArrays, knightMoves };\n","'use strict';\n\nimport { findEnd, path, sameArrays, knightMoves } from './knight-travails';\nimport { Node } from './node';\n\nwindow.findEnd = findEnd;\nwindow.givePath = path;\nwindow.Node = Node;\n\nwindow.sameArrays = sameArrays;\nwindow.knightMoves = knightMoves;\n"],"names":["Node","constructor","vertex","creator","this","neighbors","findNeighbors","rowIndex","columnIndex","length","i","traverseColumn","traverseRow","push","path","node","list","unshift","sameArrays","arr1","arr2","every","item","index","findEnd","desiredPosition","currentRoot","que","visitedNodes","count","pathFound","endPositionNode","neighborNodes","forEach","some","element","newNode","filter","shift","console","log","window","givePath","knightMoves","start","end","alert","getEndNode"],"sourceRoot":""}